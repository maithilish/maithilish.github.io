<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=description content="Explains steps to recover from failing disk or wrong commands. It also shows how to intentionally corrupt the test disk so that you get enough practice by recovering it."><meta name=author content="Maithilish"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><script async src="https://www.googletagmanager.com/gtag/js?id=G-QYHTHXW09H"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-QYHTHXW09H")</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://google.com/article"},"articleSection":"post","name":"Linux Data Recovery","headline":"Linux Data Recovery","url":"https://www.codetab.org/post/linux-data-recovery/","description":"Explains steps to recover from failing disk or wrong commands. It also shows how to intentionally corrupt the test disk so that you get enough practice by recovering it.","inLanguage":"en","image":"https://www.codetab.org/logo.jpg","author":"Maithilish","creator":"Maithilish","publisher":{"@type":"Organization","name":"Maithilish","url":"https://www.codetab.org/","logo":{"@type":"ImageObject","url":"https://www.codetab.org/logo.png","width":"200","height":"200"}},"copyrightHolder":"Maithilish","copyrightYear":"2024","datePublished":"2024-10-11T11:30:00Z","dateModified":"2024-10-11T11:30:00Z","wordCount":"3011","keywords":["Data Recovery Linux Ubuntu LVM GPT Ext4 filesystem disk metadat corruption intentionally","Blog"]}</script><link rel=icon href=/favicon.ico><link rel=stylesheet href=/css/vendor.min.b34f4a49e8fbf83dd7dd8f945eb35a939c19aa15051f677ac5a9c057ac6c8774.css integrity="sha256-s09KSej7+D3X3Y+UXrNak5wZqhUFH2d6xanAV6xsh3Q="><title>Linux Data Recovery</title>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1281079745125126" crossorigin=anonymous></script></head><body id=top><header><nav id=navbar-main class="navbar fixed-top navbar-light navbar-expand-lg bg-white border-bottom shadow-sm"><div class=container-fluid><a class=navbar-brand href=/>Codetab</a>
<button class=navbar-toggler type=button data-toggle=collapse data-target=#navbar aria-controls=navbar aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbar><ul class="navbar-nav ml-auto"><li class=nav-item><a class=nav-link href=/#tutorials><span>Home</span></a></li><li class=nav-item><a class=nav-link href=/#projects><span>Projects</span></a></li><li class=nav-item><a class=nav-link href=/post><span>Posts</span></a></li><li class=nav-item><a class=nav-link href=/#about><span>About</span></a></li></ul></div></div></nav></header><div class=container-fluid><div class=row>&nbsp;</div><div class=row><div id=contentspace class="col-md-8 post-basic order-md-2"><h2>Linux Data Recovery</h2><small class=text-muted>Oct 11, 2024 . 15 min read</small><div id=share class="row mx-0 justify-content-end"><div title=twitter><a href="https://twitter.com/intent/tweet?url=https://www.codetab.org/post/linux-data-recovery/&amp;text=Linux%20Data%20Recovery" target=_blank rel=noopener><i class="icon-twitter-squared text-secondary"></i></a></div><div title=facebook><a href="https://www.facebook.com/sharer.php?u=https://www.codetab.org/post/linux-data-recovery/&amp;t=Linux%20Data%20Recovery" target=_blank rel=noopener><i class="icon-facebook-squared text-secondary"></i></a></div><div title=linkedin><a href="https://www.linkedin.com/shareArticle?url=https://www.codetab.org/post/linux-data-recovery/&amp;title=Linux%20Data%20Recovery" target=_blank rel=noopener><i class="icon-linkedin-squared text-secondary"></i></a></div><div title=email><a href="mailto:?subject=Linux%20Data%20Recovery&amp;body=https://www.codetab.org/post/linux-data-recovery/" target=_blank rel=noopener><i class="icon-mail-squared text-secondary"></i></a></div><div title=whatsapp><a href="https://web.whatsapp.com/send?text=Linux%20Data%20Recovery%20https://www.codetab.org/post/linux-data-recovery/" target=_blank rel=noopener><i class="icon-whatsapp text-secondary"></i></a></div><div title=reddit><a href="https://reddit.com/submit?url=https://www.codetab.org/post/linux-data-recovery/&amp;title=Linux%20Data%20Recovery" target=_blank rel=noopener><i class="icon-reddit-alien text-secondary"></i></a></div><i class="icon-blank ctab-transparent"></i></div><hr class=my-3><main id=content class=post-basic><h1 id=table-of-contents>Table of Contents</h1><ul><li><a href=#data-recovery>Data Recovery</a><ul><li><a href=#practice-setup>Practice Setup</a><ul><li><a href=#create-test-disk-in-cli>Create Test Disk in CLI</a></li></ul></li><li><a href=#disk-images>Disk Images</a><ul><li><a href=#create-recovery-image>Create Recovery Image</a></li><li><a href=#mount-recovery-image>Mount Recovery Image</a></li><li><a href=#clone-the-failing-disk>Clone the Failing Disk</a></li></ul></li><li><a href=#recover-gpt>Recover GPT</a><ul><li><a href=#backup-and-restore-gpt>Backup and Restore GPT</a></li><li><a href=#how-to-corrupt-gpt>How to corrupt GPT</a></li><li><a href=#recover-the-corrupted-gpt>Recover the corrupted GPT</a></li><li><a href=#recover-lost-partition>Recover Lost Partition</a></li></ul></li><li><a href=#recover-lvm>Recover LVM</a><ul><li><a href=#lvm-metadata>LVM Metadata</a></li><li><a href=#recover-from-missing-pv>Recover from missing PV</a></li><li><a href=#recover-from-missing-lvm-text-metadata>Recover from missing LVM text metadata</a></li><li><a href=#recover-from-lv-and-vg-errors>Recover from LV and VG errors</a></li></ul></li><li><a href=#recover-ext4>Recover Ext4</a><ul><li><a href=#view-superblock-and-backups>View Superblock and Backups</a></li><li><a href=#overwrite-superblock-and-recover>Overwrite Superblock and Recover</a></li><li><a href=#recover-deleted-files>Recover Deleted Files</a></li><li><a href=#recover-txt-files>Recover Txt Files</a></li><li><a href=#mount-with-ext4-offset>Mount with ext4 offset</a></li><li><a href=#ext4-fs-without-gpt>Ext4 FS without GPT</a></li></ul></li></ul></li></ul><p><a name=data-recovery></a></p><h1 id=data-recovery>Data Recovery</h1><p>Data recovery may broadly divided into two categories - the failing disk or wrong disk management command is executed by mistake.</p><p>I personally prefer data backup over data recovery for the reason that when a disk is failing we may or may not be able to fully recover the data. It is always better to have a backup of critical data, and I have an automated setup of <a href=https://codetab.org/post/borg-backup>Borg Backup</a> that takes care to back up all important data, on daily and weekly basis, to another disk. However, there are many situations - partition deleted by accident or lv is removed so on - when data recovery techniques comes handy for fast recovery.</p><p>This post covers recovery steps specific to GPT partition table, LVM and Ext4 fs; a frequently used stack in Linux. It also shows how to intentionally corrupt the test disk so that you get enough practice by recovering it. The steps are more or less same to other FS types and partition table schemes: for other types use relevant utilities.</p><p><a name=practice-setup></a></p><h2 id=practice-setup>Practice Setup</h2><p>For practice and testing, it is convenient to use a pen drive. For commands, in this post, we use variables such as $TEST_DISK or $TEST_DEV for disk and devices such as /dev/sdc or /dev/sdc1 etc., This is done so to avoid any harm to /dev/sdc that may have been taken up by a live disk in the system. Use <code>lsblk</code> to know the device name of the pen drive and replace <code>/dev/sdx</code> with it in following exports,</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>export</span> <span class=nv>TEST_DISK</span><span class=o>=</span>/dev/sdx<span class=p>;</span> <span class=nb>export</span> <span class=nv>TEST_DEV</span><span class=o>=</span>/dev/sdx1 <span class=p>;</span> <span class=nb>export</span> <span class=nv>TEST_DEV2</span><span class=o>=</span>/dev/sdx2
</span></span></code></pre></div><p>The $TEST_DISK refers to the disk whereas $TEST_DEV and $TEST_DEV2 refers to first and second partition of the disk.</p><p><a name=create-test-disk-in-cli></a></p><h3 id=create-test-disk-in-cli>Create Test Disk in CLI</h3><p>We can use fdisk, parted or gparted to create the test disk. The sgdisk and gdisk are similar partition tools that are meant specifically for GPT tables. We use sgdisk to create the test pen drive from cmd line.</p><p>The <code>sgdisk</code> is non-interactive that writes directly to the disk, so be careful when you are using it. No rollback! Safer alternatively would be the interactive tool <code>gdisk</code> which make changes in memory and writes to disk only when you explicitly write at the end of session. Export variable as explained above before executing these commands.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>
</span></span><span class=line><span class=cl>umount <span class=nv>$TEST_DEV</span> <span class=nv>$TEST_DEV2</span>
</span></span><span class=line><span class=cl>sgdisk -og <span class=nv>$TEST_DISK</span>
</span></span><span class=line><span class=cl>partprobe <span class=nv>$TEST_DISK</span>
</span></span><span class=line><span class=cl>sgdisk -n 1:1MiB:201MiB <span class=nv>$TEST_DISK</span>
</span></span><span class=line><span class=cl>sgdisk -n 2:202MiB:502MiB <span class=nv>$TEST_DISK</span>
</span></span><span class=line><span class=cl>partprobe <span class=nv>$TEST_DISK</span>
</span></span><span class=line><span class=cl>sgdisk -p <span class=nv>$TEST_DISK</span>
</span></span><span class=line><span class=cl>wipefs -a <span class=nv>$TEST_DEV</span> <span class=nv>$TEST_DEV2</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>mkfs.ext4 <span class=nv>$TEST_DEV</span>
</span></span><span class=line><span class=cl>mkfs.ext4 <span class=nv>$TEST_DEV2</span>
</span></span></code></pre></div><p><a name=disk-images></a></p><h2 id=disk-images>Disk Images</h2><p>For data recovery of failing disk, it is best to work on image of disk rather than physical disk itself. GNU ddrescue is used to rescue failing disk. It copies data from a disk to an image or another disk trying hard to rescue data in case of read errors. It uses log file to speed up the recovery process in case of multiple runs.</p><p>Do not attempt a file system check on a failing drive, as this will likely make the problem worse. Mount the disk read-only.</p><p><a name=create-recovery-image></a></p><h3 id=create-recovery-image>Create Recovery Image</h3><p>Create backup image</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>
</span></span><span class=line><span class=cl>ddrescue -d <span class=nv>$TEST_DISK</span> backup.img backup.log    // <span class=k>if</span> fails <span class=k>then</span> try with <span class=m>3</span> retries
</span></span><span class=line><span class=cl>ddrescue -d -r3 <span class=nv>$TEST_DISK</span> backup.img backup.log  // <span class=m>3</span> retries
</span></span></code></pre></div><p><a name=mount-recovery-image></a></p><h3 id=mount-recovery-image>Mount Recovery Image</h3><p>We can mount and inspect the image,</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>
</span></span><span class=line><span class=cl>losetup -f -P backup.img         // create loop devices
</span></span><span class=line><span class=cl>losetup -l                       // list lo loop devices
</span></span><span class=line><span class=cl>mount /dev/loop16p1 /mnt
</span></span></code></pre></div><p><a name=clone-the-failing-disk></a></p><h3 id=clone-the-failing-disk>Clone the Failing Disk</h3><p>Directly clone the failing disk,</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>
</span></span><span class=line><span class=cl>ddrescue -d -r3 <span class=nv>$TEST_DISK</span> /dev/sdx1 backup.log
</span></span></code></pre></div><p>We can also clone the image created by ddrescue,</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>
</span></span><span class=line><span class=cl>ddrescue -f backup.img /dev/sdx clone.log           // copies recovered image to /dev/sdx
</span></span><span class=line><span class=cl>dd <span class=k>if</span><span class=o>=</span>backup.img <span class=nv>of</span><span class=o>=</span>/dev/sdx --status<span class=o>=</span>progress      // or we can also <span class=k>do</span> the same with dd
</span></span></code></pre></div><p>More info: <a href=https://help.ubuntu.com/community/DataRecovery>Ubuntu Data Recovery</a>.</p><p><a name=recover-gpt></a></p><h2 id=recover-gpt>Recover GPT</h2><p><a name=backup-and-restore-gpt></a></p><h3 id=backup-and-restore-gpt>Backup and Restore GPT</h3><p>Instead of using testdisk to recover the GPT, it better to have backup of the table. The gdisk is interactive GUID partition table (GPT) manipulator is used to backup and recover partition table. the gdisk holds changes in the memory and disk is updated only on write (w option).</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>
</span></span><span class=line><span class=cl>gdisk <span class=nv>$TEST_DISK</span>
</span></span></code></pre></div><p>Use option b to backup GPT to file. To recover the GPT from file, use r -> l -> w.</p><pre><code>b - backup table to file
r - recovery mode
l - load table from backup file
w - write changes
</code></pre><p>To re-read The Partition Table without rebooting,</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>
</span></span><span class=line><span class=cl>partprobe <span class=nv>$TEST_DISK</span>
</span></span></code></pre></div><p>We can also use dd to take backup</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>
</span></span><span class=line><span class=cl>dd <span class=k>if</span><span class=o>=</span><span class=nv>$TEST_DISK</span> <span class=nv>of</span><span class=o>=</span>gpt.backup <span class=nv>bs</span><span class=o>=</span><span class=m>512</span> <span class=nv>count</span><span class=o>=</span><span class=m>34</span>
</span></span><span class=line><span class=cl>dd <span class=k>if</span><span class=o>=</span>gpt.backup <span class=nv>of</span><span class=o>=</span><span class=nv>$TEST_DISK</span> <span class=nv>bs</span><span class=o>=</span><span class=m>512</span> <span class=nv>count</span><span class=o>=</span><span class=m>34</span>      // recover
</span></span></code></pre></div><p>Notes: For a bootable disk, a Protective MBR must be located at LBA 0 (i.e., the first logical block) of the disk if it is using the GPT disk layout. The Protective MBR precedes the GUID Partition Table Header to maintain compatibility with existing tools that do not understand GPT partition structures.</p><p>More info on <a href=https://uefi.org/specs/UEFI/2.10/05_GUID_Partition_Table_Format.html>GPT Partition Table Format</a>.</p><p><a name=how-to-corrupt-gpt></a></p><h3 id=how-to-corrupt-gpt>How to corrupt GPT</h3><p>To practice recovery, we can simulate the table corruption by zeroing certain sectors.</p><p>Most disks are divided into sectors of 512 bytes and the first 34 sectors of the disk are used by GPT. The MBR is located in the 1st sector of the disk (LBA 0); the GPT disks still have a &ldquo;protective&rdquo; MBR in this sector for backward compatibility. The GPT proper starts at the 2nd sector of the disk (LBA 1) where the Partition table header is located and followed, normally, by 32 sectors (16 KiB or 16384 bytes) containing the actual partition entries.</p><p>LBA0 - MBR (1 sector)
LBA1 - Partition table header (1 sector)
LBA2–33 - Partition entries (32 sectors)</p><p>The below command shows the GPT table. The GPT table starts with EFI PART in ASCII.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>
</span></span><span class=line><span class=cl>dd <span class=k>if</span><span class=o>=</span>/dev/sda <span class=nv>bs</span><span class=o>=</span><span class=m>512</span> <span class=nv>skip</span><span class=o>=</span><span class=m>1</span> <span class=nv>count</span><span class=o>=</span><span class=m>33</span> <span class=p>|</span> hexdump -C
</span></span></code></pre></div><p>To dump fs in part 1 starting at 2048 sector (1MB) use,</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>
</span></span><span class=line><span class=cl>dd <span class=k>if</span><span class=o>=</span><span class=nv>$TEST_DISK</span> <span class=nv>bs</span><span class=o>=</span><span class=m>512</span> <span class=nv>count</span><span class=o>=</span><span class=m>3</span> <span class=nv>skip</span><span class=o>=</span><span class=m>2048</span> <span class=p>|</span> hexdump -C
</span></span></code></pre></div><p>If disk is zeroed before GPT is created, then following shows MBR, GPT and File System in first partition.</p><pre tabindex=0><code class=language-Screen data-lang=Screen>
dd if=$TEST_DISK bs=512 count=2051 | hexdump -C

    00000000  hex omitted  |................|  // sector 0 - MBR, sector 0
    *
    000001f0               |..............U.|
    00000200               |EFI PART....\...|  // sector 1-33 - GPT
    00000210               |.e..............|
    *
    00100400               |........s...e...|  // sector 2048 - Part 1 FS
</code></pre><p>We can intentionally corrupt the GPT and MBR using,</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>
</span></span><span class=line><span class=cl>dd <span class=k>if</span><span class=o>=</span>/dev/zero <span class=nv>of</span><span class=o>=</span><span class=nv>$TEST_DISK</span> <span class=nv>bs</span><span class=o>=</span><span class=m>512</span> <span class=nv>count</span><span class=o>=</span><span class=m>34</span>            // zeros the GPT and MBR
</span></span><span class=line><span class=cl>dd <span class=k>if</span><span class=o>=</span>/dev/zero <span class=nv>of</span><span class=o>=</span><span class=nv>$TEST_DISK</span> <span class=nv>bs</span><span class=o>=</span><span class=m>512</span> <span class=nv>count</span><span class=o>=</span><span class=m>33</span> <span class=nv>seek</span><span class=o>=</span><span class=m>1</span>     // zerors the GPT <span class=o>(</span>seek skips MBR sector<span class=o>)</span>
</span></span></code></pre></div><p>When GPT is zeroed but fs data is not touched, then we can recover the disk by creating a new GPT and adding new part of same size. New GPT recognize the fs without any error.</p><p>Points to Note:</p><ol><li><p>Creating fresh GPT will zeros the GPT area but not the MBR. For testing, zero the first 34 sectors with dd if=/dev/zero of=$TEST_DISK bs=512 count=34.</p></li><li><p>Creating part alters the part table at sector 1, but it doesn&rsquo;t put anything at start sector of the part. The mkfs.ext4 writes at first sector of the part.</p></li></ol><p><a name=recover-the-corrupted-gpt></a></p><h3 id=recover-the-corrupted-gpt>Recover the corrupted GPT</h3><p>Corrupt the GPT as explained above. Now <code>gdisk $TEST_DISK</code> shows following message</p><pre tabindex=0><code class=language-Screen data-lang=Screen>
****
Caution: Found protective or hybrid MBR and corrupt GPT. Using GPT, but disk
verification and recovery are STRONGLY recommended.
****
</code></pre><p>The GPT maintains a backup table at the end of disk. We can recover from the backup table using <code>gdisk $TEST_DISK</code> and use r (recovery mode) -> c (load backup table) -> w (write).</p><p>If you have taken gpt backup using gdisk -> b option then restore the table from it using gdisk&rsquo;s r (recovery) -> l (load backup) option.</p><p><a name=recover-lost-partition></a></p><h3 id=recover-lost-partition>Recover Lost Partition</h3><p>There are situation when we accidentally delete a partition and then it is lost. We can simulate this by deleting a partition using gdisk or sgdisk. The backup created by GPT at the end of disk is not useful in this case as the deleted part is also removed from the backup. We can restore the GPT if we have backup created using gdisk b option as explained earlier.</p><p>In case you don&rsquo;t have GPT backup file then try to recover using <code>testdisk</code> utility which is good tool to recover lost partition.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>
</span></span><span class=line><span class=cl>sgdisk -d <span class=m>1</span> <span class=nv>$TEST_DISK</span>
</span></span></code></pre></div><p>To recover file</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>
</span></span><span class=line><span class=cl>testdisk <span class=nv>$TEST_DISK</span>
</span></span></code></pre></div><p>The steps to recover are, Select EFI GPT -> Proceed -> Analyze -> Quick Search. The data parts are shown in green. Select any one and press Enter. Choose Write option to write the gpt. It may create extra blank partitions, delete such parts with gdisk.</p><p>In case <code>testdisk</code> is unable to write the GPT, then find out the lost partition&rsquo;s first and last sector with Analyze -> Quick Search. Then you can use it re-create the partition using gdisk.</p><p>If you have lot of partitions in disk then it is better to take backup of the GPT as explained below. The backup comes handy recover the lost partition.</p><p><a name=recover-lvm></a></p><h2 id=recover-lvm>Recover LVM</h2><p>LVM backup files are in <code>/etc/lvm/backup</code> and <code>/etc/lvm/archive</code>. The backup file is readable and shows the lvm conf before or after executing lvm change commands. We can use these files to restore corrupted or lost lvm.</p><p><a name=lvm-metadata></a></p><h3 id=lvm-metadata>LVM Metadata</h3><p>LVM maintains two types of metadata in each PV to manage. Sectors are zero indexed and sector 0 is not used by LVM.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>
</span></span><span class=line><span class=cl>pvcreate <span class=nv>$TEST_DEV</span>
</span></span><span class=line><span class=cl>pvck <span class=nv>$TEST_DEV</span>
</span></span><span class=line><span class=cl>  Found label on /dev/sdc1, sector 1, <span class=nv>type</span><span class=o>=</span>LVM2 <span class=m>001</span>
</span></span><span class=line><span class=cl>  Found text metadata area: <span class=nv>offset</span><span class=o>=</span>4096, <span class=nv>size</span><span class=o>=</span><span class=m>1044480</span>
</span></span></code></pre></div><p>The pv label is on first sector. The sector 8 to sector 2048 (1MB space) is reserved for text metadata. The fs starts , normally, from sector 2048.</p><p>The <code>pvcreate</code> writes physical volume label to mark the block device as an LVM PV in any of sector 1 to 4. By default, the pvcreate command places the label in the 1st sector device sdc1,sdc2 etc., This label can optionally be placed in any of the first four sectors, since the LVM tools scan the first 4 sectors. The physical volume label begins with the string LABELONE. The <code>pvremove</code> wipes the labels by zeroing these sectors.</p><p>We can view the PV label using,</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>
</span></span><span class=line><span class=cl>dd <span class=k>if</span><span class=o>=</span><span class=nv>$TEST_DEV</span> <span class=nv>bs</span><span class=o>=</span><span class=m>512</span> <span class=nv>skip</span><span class=o>=</span><span class=m>1</span> <span class=nv>count</span><span class=o>=</span><span class=m>4</span> <span class=p>|</span> hexdump -C
</span></span></code></pre></div><p>The &ldquo;real&rdquo; metadata comes when we do a <code>vgcreate</code> and <code>lvcreate</code>. The configuration details of a volume group are referred to as the metadata. By default, an identical copy of the metadata is maintained in every metadata area in every physical volume within the volume group. LVM volume group metadata is stored as ASCII. The metadata area is a circular buffer. View metadata with,</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>
</span></span><span class=line><span class=cl>dd <span class=k>if</span><span class=o>=</span><span class=nv>$TEST_DEV</span> <span class=nv>bs</span><span class=o>=</span><span class=m>512</span> <span class=nv>skip</span><span class=o>=</span><span class=m>8</span> <span class=nv>count</span><span class=o>=</span><span class=m>4</span> <span class=p>|</span> hexdump -C
</span></span></code></pre></div><p>More info on <a href=https://docs.redhat.com/en/documentation/red_hat_enterprise_linux/5/html/logical_volume_manager_administration/lvm_metadata>LVM Metadata</a>.</p><p><a name=recover-from-missing-pv></a></p><h3 id=recover-from-missing-pv>Recover from missing PV</h3><p>The PV may be missing because of PV label corruption or removed, by force, with command <code>pvremove -ff $TEST_DEV</code>.</p><p>We can simulate missing PV with any of below commands. Then <code>vgs</code> will show missing PV warning.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>
</span></span><span class=line><span class=cl>dd <span class=k>if</span><span class=o>=</span><span class=nv>$TEST_DEV</span> <span class=nv>bs</span><span class=o>=</span><span class=m>512</span> <span class=nv>skip</span><span class=o>=</span><span class=m>1</span> <span class=nv>count</span><span class=o>=</span><span class=m>4</span> <span class=p>|</span> hexdump -C
</span></span><span class=line><span class=cl>dd <span class=k>if</span><span class=o>=</span>/dev/zero <span class=nv>of</span><span class=o>=</span><span class=nv>$TEST_DEV</span> <span class=nv>bs</span><span class=o>=</span><span class=m>512</span> <span class=nv>seek</span><span class=o>=</span><span class=m>1</span> <span class=nv>count</span><span class=o>=</span><span class=m>1</span>      // zero the pv label in first sector
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>or
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>pvremove -ff <span class=nv>$TEST_DEV</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>vgs
</span></span></code></pre></div><p>Now, we can&rsquo;t restore it with <code>vgcfgrestore -f /etc/lvm/backup/bk bk</code>. To recover PV, find out the missing PV&rsquo;s uuid and the device name using <code>vgs</code>. Deactivate any active lv in the vg and recreate the PV either using lvm backup or archive file.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>
</span></span><span class=line><span class=cl>lvchange --activate n bk/bk
</span></span><span class=line><span class=cl>pvcreate --test --uuid <span class=s2>&#34;&lt;uuid&gt;&#34;</span> --restorefile /etc/lvm/backup/bk <span class=nv>$TEST_DEV</span>  // dry run
</span></span><span class=line><span class=cl>pvcreate --uuid <span class=s2>&#34;&lt;uuid&gt;&#34;</span> --restorefile /etc/lvm/backup/bk <span class=nv>$TEST_DEV</span>
</span></span><span class=line><span class=cl>lvchange --activate y bk/bk
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>pvck <span class=nv>$TEST_DEV</span>
</span></span></code></pre></div><p>Finally restore VG to fix the warning &ldquo;VG bk is missing the used flag in PV header&rdquo;</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>
</span></span><span class=line><span class=cl>vgcfgrestore --test -f /etc/lvm/backup/bk bk
</span></span><span class=line><span class=cl>vgcfgrestore -f /etc/lvm/backup/bk bk
</span></span></code></pre></div><p><a name=recover-from-missing-lvm-text-metadata></a></p><h3 id=recover-from-missing-lvm-text-metadata>Recover from missing LVM text metadata</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>
</span></span><span class=line><span class=cl>dd <span class=k>if</span><span class=o>=</span><span class=nv>$TEST_DEV</span> <span class=nv>bs</span><span class=o>=</span><span class=m>512</span> <span class=nv>skip</span><span class=o>=</span><span class=m>8</span> <span class=nv>count</span><span class=o>=</span><span class=m>4</span> <span class=p>|</span> hexdump -C
</span></span><span class=line><span class=cl>dd <span class=k>if</span><span class=o>=</span>/dev/zero <span class=nv>of</span><span class=o>=</span><span class=nv>$TEST_DEV</span> <span class=nv>bs</span><span class=o>=</span><span class=m>512</span> <span class=nv>seek</span><span class=o>=</span><span class=m>8</span> <span class=nv>count</span><span class=o>=</span><span class=m>4</span>
</span></span></code></pre></div><p>The missing text metadata will trigger warning in lvs, vgs and pvs. Repair first disk</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>
</span></span><span class=line><span class=cl>pvck --repair -f /etc/lvm/backup/bk <span class=nv>$TEST_DEV</span>
</span></span></code></pre></div><p>Run lvs, vgs and pvs. If it shows metadata mismatch in second disk then do,</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>
</span></span><span class=line><span class=cl>pvck --repair -f /etc/lvm/backup/bk <span class=nv>$TEST_DEV2</span>
</span></span></code></pre></div><p>Run lvs, vgs and pvs. Now things should be ok else run</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>
</span></span><span class=line><span class=cl>lvchange --activate n bk/bk
</span></span><span class=line><span class=cl>pvcreate --test --uuid <span class=s2>&#34;&lt;uid of pv&gt;&#34;</span> --restorefile /etc/lvm/backup/bk <span class=nv>$TEST_DEV</span>
</span></span><span class=line><span class=cl>pvcreate --uuid <span class=s2>&#34;&lt;uid of pv&gt;&#34;</span> --restorefile /etc/lvm/backup/bk <span class=nv>$TEST_DEV</span>
</span></span><span class=line><span class=cl>lvchange --activate y bk/test
</span></span><span class=line><span class=cl>pvck <span class=nv>$TEST_DEV</span>
</span></span></code></pre></div><p>Finally, check fs</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>
</span></span><span class=line><span class=cl>fsck.ext4 -f /dev/mapper/bk-bk
</span></span></code></pre></div><p><a name=recover-from-lv-and-vg-errors></a></p><h3 id=recover-from-lv-and-vg-errors>Recover from LV and VG errors</h3><p>We may remove lv and vg by mistake. Use backups in <code>/etc/lvm/archive</code> folder to recover from this.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>
</span></span><span class=line><span class=cl>lvremove bk bk              // LV removed accidentally
</span></span><span class=line><span class=cl>vgcfgrestore -l bk          // list backup in archive <span class=k>for</span> a VG
</span></span><span class=line><span class=cl>vgcfgrestore -f /etc/lvm/archive/bk_00042-1381804649.vg bk
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>lvs
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>vgremove bk
</span></span><span class=line><span class=cl>vgcfgrestore -l bk
</span></span><span class=line><span class=cl>vgcfgrestore -f /etc/lvm/archive/bk_00042-1381804649.vg bk
</span></span><span class=line><span class=cl>vgs
</span></span><span class=line><span class=cl>lvs
</span></span></code></pre></div><p>For more info: <a href=https://docs.hetzner.com/robot/dedicated-server/troubleshooting/recovery-of-lvm-volumes/>LVM Recovery</a></p><p><a name=recover-ext4></a></p><h2 id=recover-ext4>Recover Ext4</h2><p><a name=view-superblock-and-backups></a></p><h3 id=view-superblock-and-backups>View Superblock and Backups</h3><p>The backups are created as soon as fs is created with mkfs.ext4, there is no need to mount or write files. For less than 120M part, no superblock backups are created! They are created when part size is 130M (approx).</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>
</span></span><span class=line><span class=cl>dumpe2fs <span class=nv>$TEST_DEV</span> <span class=p>|</span> grep -i superblock
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  Primary superblock at 0, Group descriptors at 1-13
</span></span><span class=line><span class=cl>  Backup superblock at 32768, Group descriptors at 32769-32781
</span></span><span class=line><span class=cl>  Backup superblock at 98304, Group descriptors at 98305-98317
</span></span></code></pre></div><p>The superblocks are relative to the partition. The first backup of superblock is at 32768 block (4k) within $TEST_DEV (/dev/sdx1) and not of $TEST_DISK (/dev/sdx).</p><p>We can also use following cmd where -n is for dry run. It is safe say Y to overwrite warning message as it doesn&rsquo;t create or touch the fs.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>
</span></span><span class=line><span class=cl>mkfs.ext4 -n <span class=nv>$TEST_DEV</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    Creating filesystem with <span class=m>495616</span> 4k blocks and <span class=m>123904</span> inodes
</span></span><span class=line><span class=cl>    Filesystem UUID: 3fef5d22-6bf8-493c-bbfd-3441128497e2
</span></span><span class=line><span class=cl>    Superblock backups stored on blocks:
</span></span><span class=line><span class=cl>    	32768, 98304, 163840, 229376, <span class=m>294912</span>
</span></span></code></pre></div><p>Use dd to view the super block. The ext4 default block size is 4096b. The following cmds dump primary at 0, first backup at 32768 and second backup at 98304. To convert ext4 block to disk sector multiple ext4 block by 8. Ex: ext4 block 32768 is disk sector 262144.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>
</span></span><span class=line><span class=cl>dd <span class=k>if</span><span class=o>=</span><span class=nv>$TEST_DEV</span> <span class=nv>bs</span><span class=o>=</span><span class=m>512</span> <span class=nv>skip</span><span class=o>=</span><span class=m>2</span> <span class=nv>count</span><span class=o>=</span><span class=m>3</span> <span class=p>|</span> hexdump -C
</span></span><span class=line><span class=cl>dd <span class=k>if</span><span class=o>=</span><span class=nv>$TEST_DEV</span> <span class=nv>bs</span><span class=o>=</span><span class=m>512</span> <span class=nv>skip</span><span class=o>=</span><span class=m>262144</span> <span class=nv>count</span><span class=o>=</span><span class=m>1</span> <span class=p>|</span> hexdump -C
</span></span><span class=line><span class=cl>dd <span class=k>if</span><span class=o>=</span><span class=nv>$TEST_DEV</span> <span class=nv>bs</span><span class=o>=</span><span class=m>512</span> <span class=nv>skip</span><span class=o>=</span><span class=m>786432</span> <span class=nv>count</span><span class=o>=</span><span class=m>1</span> <span class=p>|</span> hexdump -C
</span></span></code></pre></div><p><a name=overwrite-superblock-and-recover></a></p><h3 id=overwrite-superblock-and-recover>Overwrite Superblock and Recover</h3><p>Overwrite first superblock with zero.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>
</span></span><span class=line><span class=cl>dd <span class=k>if</span><span class=o>=</span><span class=nv>$TEST_DEV</span> <span class=nv>bs</span><span class=o>=</span><span class=m>1</span> <span class=nv>skip</span><span class=o>=</span><span class=m>1024</span> <span class=nv>count</span><span class=o>=</span><span class=m>512</span> <span class=p>|</span> hexdump -C
</span></span><span class=line><span class=cl>dd <span class=k>if</span><span class=o>=</span>/dev/zero <span class=nv>of</span><span class=o>=</span><span class=nv>$TEST_DEV</span> <span class=nv>bs</span><span class=o>=</span><span class=m>1</span> <span class=nv>seek</span><span class=o>=</span><span class=m>1024</span> <span class=nv>count</span><span class=o>=</span><span class=m>256</span>
</span></span></code></pre></div><p>Recover it with fsck.ext4,</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>
</span></span><span class=line><span class=cl>fsck.ext4 <span class=nv>$TEST_DEV</span>
</span></span><span class=line><span class=cl>fsck.ext4 -vf <span class=nv>$TEST_DEV</span>
</span></span></code></pre></div><p>Note: Run fsck for partition such as /dev/sdx1. Don&rsquo;t run it for /dev/sdx as it will corrupt GPT unless you have formated full disk as ext4 without any partition table. It is possible to recover GPT with gdisk but don&rsquo;t know whether it works in all cases.</p><p><a name=recover-deleted-files></a></p><h3 id=recover-deleted-files>Recover Deleted Files</h3><p>Out of file un-delete tools - testdisk, photorec, ext4magic and foremost, the photorec is able recover many types of files. The testdisk can&rsquo;t recover from ext4, while foremost can recover limited set of files types. The ext4magic sometime able to recover the files depending on state of the ext4 journal.</p><p>The <code>photorec</code> ignores the filesystem and goes after the underlying data, so it will work even with a re-formatted or severely damaged filesystems and/or partition tables. The photorec is unable to recover txt and text based files such as .java etc.,</p><p>Text files cannot be recovered by automatic &ldquo;scanning&rdquo; tools like foremost or photorec because there&rsquo;s no way to identify them amongst the other data as txt file doesn&rsquo;t have a header.</p><p>To tryout photorec, mount $TEST_DEV2 and cp some files and delete some. Run <code>photorec $TEST_DEV2</code> and use option Proceed -> Choose partition unknown (whole disk) -> Search -> Choose Ext4 -> Destination Folder (select current dir) -> C. The recovered files are saved in <code>recup_dir</code> folder.</p><p>To recover using ext4magic first create backup of journal and then recover from it.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>
</span></span><span class=line><span class=cl>debugfs -R <span class=s2>&#34;dump &lt;8&gt; /tmp/backup.journal&#34;</span> <span class=nv>$TEST_DEV2</span>
</span></span><span class=line><span class=cl>ddrescue -r3 -v <span class=nv>$TEST_DEV2</span> backup.img backup.log
</span></span><span class=line><span class=cl>ext4magic backup.img -a <span class=s2>&#34;</span><span class=k>$(</span>date -d <span class=s2>&#34;-1days&#34;</span> +%s<span class=k>)</span><span class=s2>&#34;</span> -j /tmp/backup.journal -r
</span></span></code></pre></div><p>Or you directly use the disk without taking image.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>
</span></span><span class=line><span class=cl>debugfs -R <span class=s2>&#34;dump &lt;8&gt; /tmp/sdc2.journal&#34;</span> /dev/sdc2
</span></span><span class=line><span class=cl>ext4magic /dev/sdc2 -a <span class=s2>&#34;</span><span class=k>$(</span>date -d <span class=s2>&#34;-1days&#34;</span> +%s<span class=k>)</span><span class=s2>&#34;</span> -j /tmp/sdc2.journal -r
</span></span></code></pre></div><p>The recovery depends on state of journal, and may times ext4magic is unable to recover any files. The flag -r will only recover complete files, that were not overwritten. To recover broken files, that were partially overwritten, use flag -R. This will also restore not-deleted files and empty directories.</p><p>It is not possible to view deleted files by mounting the backup.img as loop device with <code>mount -o loop,ro backup.img /mnt</code>.</p><p><a name=recover-txt-files></a></p><h3 id=recover-txt-files>Recover Txt Files</h3><p>If some content of the txt file is known, then we can grep for the text and recover the txt file,</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>
</span></span><span class=line><span class=cl>grep --line-buffered -a -b -o -F -e <span class=s1>&#39;Some known text&#39;</span> <span class=nv>$TEST_DEV2</span>
</span></span><span class=line><span class=cl>dd <span class=nv>status</span><span class=o>=</span>none <span class=k>if</span><span class=o>=</span>/dev/sdc2 <span class=nv>bs</span><span class=o>=</span><span class=m>4096</span> <span class=nv>skip</span><span class=o>=</span><span class=k>$((</span> <span class=m>136318474</span> <span class=o>/</span> <span class=m>4096</span> <span class=o>-</span><span class=m>1</span> <span class=k>))</span> <span class=nv>count</span><span class=o>=</span><span class=m>2</span> <span class=p>|</span> less
</span></span></code></pre></div><p>The ext4magic may recover some of the txt files.</p><p><a name=mount-with-ext4-offset></a></p><h3 id=mount-with-ext4-offset>Mount with ext4 offset</h3><p>If you have taken the partition layout backup with <code>fdisk /dev/sdc -l</code>, then it is possible to mount fs directly without recreating the GPT.</p><p>Suppose the partition layout is,</p><pre tabindex=0><code class=language-Screen data-lang=Screen>
Device       Start     End Sectors  Size Type
/dev/sdc1     2048 1026048 1024001  500M Linux filesystem
/dev/sdc2  1028096 1437696  409601  200M Linux filesystem
</code></pre><p>In ext4 fs, the first 2 sectors (count 2) are zeros and super block starts at 1024 (count 3). If offset 00000438 contains magic number 0x53ef then it is ext fs superblock. Search for fs magic number,</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>
</span></span><span class=line><span class=cl>dd <span class=k>if</span><span class=o>=</span><span class=nv>$TEST_DISK</span> <span class=nv>bs</span><span class=o>=</span><span class=m>512</span> <span class=nv>skip</span><span class=o>=</span><span class=m>2048</span> <span class=nv>count</span><span class=o>=</span><span class=m>3</span> <span class=p>|</span> xxd -a
</span></span><span class=line><span class=cl>dd <span class=k>if</span><span class=o>=</span><span class=nv>$TEST_DISK</span> <span class=nv>bs</span><span class=o>=</span><span class=m>512</span> <span class=nv>skip</span><span class=o>=</span><span class=m>1028096</span> <span class=nv>count</span><span class=o>=</span><span class=m>3</span> <span class=p>|</span> xxd -a
</span></span></code></pre></div><p>Now we can mount with offset.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>
</span></span><span class=line><span class=cl>mount /dev/<span class=nv>$TEST_DISK</span> -o ro,offset<span class=o>=</span><span class=k>$((</span><span class=m>512</span><span class=o>*</span><span class=m>1028096</span><span class=k>))</span> /mnt
</span></span><span class=line><span class=cl>mount /dev/<span class=nv>$TEST_DISK</span> -o ro,offset<span class=o>=</span><span class=k>$((</span><span class=m>512</span><span class=o>*</span><span class=m>2048</span><span class=k>))</span> /mnt
</span></span></code></pre></div><p>When you run wipefs -a to erase the fs, it simply erases the magic number at 0x00000438 and outputs message /dev/sdc1: 2 bytes were erased at offset 0x00000438 (ext4): 53 ef.</p><p><a name=ext4-fs-without-gpt></a></p><h3 id=ext4-fs-without-gpt>Ext4 FS without GPT</h3><p>Normally partitions are created in disk, but it is also possible to create fs without gpt spanning the entire disk.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Bash data-lang=Bash><span class=line><span class=cl>
</span></span><span class=line><span class=cl>mkfs.ext4 <span class=nv>$TEST_DISK</span>
</span></span><span class=line><span class=cl>parted <span class=nv>$TEST_DISK</span> print
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    Partition Table: loop.
</span></span><span class=line><span class=cl>    Number  Start  End     Size    File system  Flags
</span></span><span class=line><span class=cl>     <span class=m>1</span>      0.00B  2030MB  2030MB  ext4
</span></span></code></pre></div></main></div><aside id=sidebar class="col-md-3 order-md-1"><div class="row my-5 justify-content-center"></div></aside><aside id=sidebar-right class="col-md-1 order-md-last"></aside></div></div><footer class="container-fluid mt-5"><div class=row><div class="col ml-auto"><div class="row mb-1 ml-2"><a class=text-muted href=/privacy-policy>Privacy</a></div><div class="row text-muted mb-2 ml-2"><span>&copy; 2019 &#183;Powered by <a href=https://gohugo.io target=_blank rel=noopener>Hugo</a></span></div></div><div class="col mr-auto"><span class=float-right><a href=# id=back_to_top><i class="icon-up-open h1 text-secondary"></i></a></span></div></div></footer><script async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script><script src=/js/vendor.min.c32ad1c7e87da9243fe3a4ff30c9040737545641e3a0a16a1cde4d62759f9fea.js></script></body></html>